#!/usr/bin/env stack
-- stack --resolver lts-21.22 ghci --package containers-0.6.7 --package split-0.2.3.5 --package safe-0.3.19 --package QuickCheck-2.14.3

{-# LANGUAGE TupleSections #-}

module AsciiWorld   ( AsciiWorld(..)
                    , MaskOrPointsIndex(..)
                    , fromMaskOrPointsIndex
                    , toMaskOrPointsIndex
                    , emptyAsciiWorld
                    , readAsciiWorld
                    , showAsciiWorld
                    , printAsciiWorld
                    , setWidth
                    , changeWidthBy
                    , mapIndexForMasks
                    , mapIndexForPoints
                    , msbPointOfMask
                    , middlePointOfMask
                    , combineTwoAsciiWorlds
                    , combineAsciiWorlds
                    , inWorldIsPointOverlappingPointsIndex
                    , inWorldIsPointsIndexOverlappingMaskIndex
                    , inWorldIsPointOverlappingMaskIndex
                    , inWorldIsPointOverlappingPointsIndexOrMaskIndex
                    , moveMaskOfIndexBy
                    , movePointsOfIndexBy
                    , addMask
                    , deleteMask
                    , filterMaskIndices
                    , filterMasks
                    , lookupMask
                    , lookupPoints
                    , adjustMask
                    , adjustPoints
                    , updateMask
                    , alterMask
                    , copyMask
                    , copyPoints
                    , applyMask
                    , setPoint
                    , deletePoints
                    , insertMaskFromPoints
                    , inWorldMaybeInsertMaskIndexFromPointsIndex
                    , isOverlappingMasks
                    , Mask ) where

-------------
-- Imports --
-------------
import Data.List (sortBy, groupBy, delete, find, transpose, sortOn, isPrefixOf)
import Data.List.Split (chunksOf)
import qualified Data.Map as M
import Data.Maybe (fromJust, isJust, catMaybes, fromMaybe)
import Data.Either
import Data.Ord
import Data.Function
import Data.Bits
import Control.Monad (guard, join)
import Data.Monoid
import Data.Foldable
import Safe (atMay)

import Util ( replace, maximumMaybeBy, filterKeys )
import Mask ( Point
            , Mask
            , pointToIndex
            , pointToMask
            , moveMask
            , movePoint
            , isOverlapping
            , bitwiseSubtract
            , bitwiseAnd
            , bitwiseOr
            , bitwiseXor
            , msbPoint
            , middlePoint
            , changeMaskWidthBy
            , setMaskWidth )

-- Each obj has a shape encoded as bits of an Integer.

data AsciiWorld mk pk
    = AsciiWorld { asciiWorldMasks :: M.Map mk Mask
                 , asciiWorldPoints :: M.Map pk [Point]
                 , asciiWorldWidth :: Int } deriving (Show)

emptyAsciiWorld :: (Ord mk, Ord pk) => Int -> AsciiWorld mk pk
emptyAsciiWorld width = AsciiWorld mempty mempty width

-- Making "Maybe (Either mk pk)" more readable.
data MaskOrPointsIndex mk pk = MaskIndex mk | PointsIndex pk deriving (Show, Eq, Ord)
fromMaskOrPointsIndex :: MaskOrPointsIndex mk pk -> Either mk pk
fromMaskOrPointsIndex (MaskIndex   x) = Left x
fromMaskOrPointsIndex (PointsIndex y) = Right y
toMaskOrPointsIndex :: Either mk pk -> MaskOrPointsIndex mk pk
toMaskOrPointsIndex (Left x)  = MaskIndex   x
toMaskOrPointsIndex (Right y) = PointsIndex y

-- Assumes all rows have equal length
readAsciiWorld :: (Ord mk, Ord pk) => (Char -> Maybe (MaskOrPointsIndex mk pk)) -> String -> (Int, AsciiWorld mk pk)
readAsciiWorld charMap inStr
    = ( height
      , AsciiWorld { asciiWorldMasks = foldl' addToMask M.empty (lefts eithers),
                     asciiWorldPoints = M.fromListWith (++) (rights eithers),
                     asciiWorldWidth = width } )
    
  where rows = lines inStr
        height = length rows
        width
          | height == 0 = 0
          | otherwise   = length $ head rows
        
        eithers = eithersFromChar2Ds . readChar2DsFromRows $ rows
        
        readChar2DsFromRows rows = do
            (y',row) <- zip [0..] rows
            (x,char) <- zip [0..] row
            
            let y = height - 1 - y'
            
            return (char, (x, y))
        
        eithersFromChar2Ds cs = do
            (c,pt) <- cs
            
            let e = charMap c
            
            guard $ isJust e
            
            let e' = case fromMaskOrPointsIndex $ fromJust e of
                        Left  e1 -> Left  (e1,pt)
                        Right e2 -> Right (e2,[pt])
            
            return e'

        addToMask m (k, (x, y)) = M.alter (setBitInMask (x, y)) k m

        setBitInMask (x, y) maybeMask = Just $ setBit (fromMaybe 0 maybeMask) (y * width + x)

changeWidthBy :: (Ord mk, Ord pk) => Int -> AsciiWorld mk pk -> AsciiWorld mk pk
changeWidthBy delta w = w { asciiWorldMasks = M.map (changeMaskWidthBy oldWidth delta) (asciiWorldMasks w)
                          , asciiWorldPoints = newPoints
                        , asciiWorldWidth = newWidth }
  where oldWidth = asciiWorldWidth w
        newWidth = oldWidth + delta
        
        oldPoints = asciiWorldPoints w
        newPoints
            | delta < 0 = M.map (filter (\(x,_) -> x < newWidth)) oldPoints
            | otherwise = oldPoints

setWidth :: (Ord mk, Ord pk) => Int -> AsciiWorld mk pk -> AsciiWorld mk pk
setWidth newWidth w = w { asciiWorldMasks = M.map (setMaskWidth oldWidth newWidth) (asciiWorldMasks w)
                        , asciiWorldPoints = newPoints
                        , asciiWorldWidth = newWidth }
  where oldWidth = asciiWorldWidth w
        
        oldPoints = asciiWorldPoints w
        newPoints
            | newWidth < oldWidth = M.map (filter (\(x,_) -> x >= newWidth)) oldPoints
            | otherwise = oldPoints

mapIndexForMasks  :: (Ord mk1, Ord mk2, Ord pk)  => (mk1 -> mk2) -> AsciiWorld mk1 pk -> AsciiWorld mk2 pk
mapIndexForMasks f w = w { asciiWorldMasks = M.mapKeys f (asciiWorldMasks w) }

mapIndexForPoints :: (Ord mk,  Ord pk1, Ord pk2) => (pk1 -> pk2) -> AsciiWorld mk pk1 -> AsciiWorld mk pk2
mapIndexForPoints f w = w { asciiWorldPoints = M.mapKeys f (asciiWorldPoints w) }

showAsciiWorld :: (Ord mk, Ord pk) => Int -> Char -> (mk -> Char) -> (pk -> Char) -> (MaskOrPointsIndex mk pk -> MaskOrPointsIndex mk pk -> Ordering) -> AsciiWorld mk pk -> String
showAsciiWorld height bgChar maskToChar pointsToChar indexZOrder world = unlines . reverse . take height . chunksOf width . map (fromMaybe bgChar) $ listOfMaybeCharsFromMasksAndPoints
  where (AsciiWorld masks points width) = world
        
        layerToMaybeMaskIndices :: (a, Mask) -> [Maybe a]
        layerToMaybeMaskIndices (mIndex, n) = map (\i -> if n `testBit` i then Just mIndex else Nothing) [0..]
        
        -- listOfMaybeEithersFromMasks :: [Maybe (Either mk pk)]
        listOfMaybeEithersFromMasks = if M.null masks
                                          then replicate (height * width) Nothing
                                          else map (maximumMaybeBy (indexZOrder `on` toMaskOrPointsIndex)) . map (map (fmap Left)) . transpose . map layerToMaybeMaskIndices . M.toList $ masks
        
        -- indicesAndPoints :: [(pk, Point)]
        indicesAndPoints = map head . groupBy ((==) `on` snd) . sortBy (\(aIndex,aPos) (bIndex,bPos) -> compare aPos bPos <> compare aIndex bIndex) . concat . map (\(name,ps) -> map (name,) ps) . M.toList $ points
        
        -- indicesAndListPositions :: [(pk, Int)]
        indicesAndListPositions = map (fmap (pointToIndex width)) indicesAndPoints
        
        -- listOfMaybeEithersFromMasksAndPoints :: [Maybe (Either mk pk)]
        listOfMaybeEithersFromMasksAndPoints = foldr update listOfMaybeEithersFromMasks indicesAndListPositions
          where update (pIndex,i) acc = let maybeOld = join (acc `atMay` i)
                                            zOrderMax = case maybeOld of
                                                          Nothing -> Right pIndex
                                                          Just old -> maximumBy (indexZOrder `on` toMaskOrPointsIndex) [old, (Right pIndex)]
                                        in replace acc (i, Just zOrderMax)
        
        -- listOfMaybeCharsFromMasksAndPoints :: [Maybe Char]
        listOfMaybeCharsFromMasksAndPoints = map (fmap (either maskToChar pointsToChar)) listOfMaybeEithersFromMasksAndPoints

printAsciiWorld :: (Ord mk, Ord pk) => Int -> Char -> (mk -> Char) -> (pk -> Char) -> (MaskOrPointsIndex mk pk -> MaskOrPointsIndex mk pk -> Ordering) -> AsciiWorld mk pk -> IO ()
printAsciiWorld height bgChar maskToChar pointsToChar indexZOrder world = putStrLn $ showAsciiWorld height bgChar maskToChar pointsToChar indexZOrder world 

msbPointOfMask :: (Ord mk, Ord pk) => mk -> AsciiWorld mk pk -> Maybe Point
msbPointOfMask maskIndex w = fmap (msbPoint width) (lookupMask maskIndex w)
  where width = asciiWorldWidth w

middlePointOfMask :: (Ord mk, Ord pk) => mk -> AsciiWorld mk pk -> Maybe Point
middlePointOfMask maskIndex w = fmap (middlePoint width) (lookupMask maskIndex w)
  where width = asciiWorldWidth w

-- Assumes asciiWorlds are same size
-- Left-biased such that the background character and any singular points they share are taken from the left
combineTwoAsciiWorlds :: (Ord mk, Ord pk) => AsciiWorld mk pk -> AsciiWorld mk pk -> AsciiWorld mk pk
combineTwoAsciiWorlds w1 w2
    = w1 { asciiWorldMasks = M.unionWith combineMasks (asciiWorldMasks w1) (asciiWorldMasks w2),
           asciiWorldPoints = M.unionWith combinePoints (asciiWorldPoints w1) (asciiWorldPoints w2) }
  where combineMasks :: Mask -> Mask -> Mask
        combineMasks = bitwiseOr
        
        combinePoints :: [Point] -> [Point] -> [Point]
        combinePoints = (++)

combineAsciiWorlds :: (Ord mk, Ord pk) => [AsciiWorld mk pk] -> AsciiWorld mk pk
combineAsciiWorlds = foldr1 combineTwoAsciiWorlds

inWorldIsPointOverlappingPointsIndex :: (Ord mk, Ord pk) => AsciiWorld mk pk -> Point -> pk -> Bool
inWorldIsPointOverlappingPointsIndex world point pointsIndex = inPoints
  where
    inPoints = case M.lookup pointsIndex (asciiWorldPoints world) of
        Just ps -> point `elem` ps
        Nothing -> False

inWorldIsPointsIndexOverlappingMaskIndex :: (Ord mk, Ord pk) => AsciiWorld mk pk -> pk -> mk -> Bool
inWorldIsPointsIndexOverlappingMaskIndex world pointsIndex maskIndex = inMask
  where
    maybePoints = M.lookup pointsIndex (asciiWorldPoints world)
    maybeMask = M.lookup maskIndex (asciiWorldMasks world)
    inMask = case (maybePoints, maybeMask) of
        (Just ps, Just bits) -> any (\point -> testBit bits (pointToIndex (asciiWorldWidth world) point)) ps
        (_,_) -> False

inWorldIsPointOverlappingMaskIndex :: (Ord mk, Ord pk) => AsciiWorld mk pk -> Point -> mk -> Bool
inWorldIsPointOverlappingMaskIndex world point maskIndex = inMask
  where
    inMask = case M.lookup maskIndex (asciiWorldMasks world) of
        Just bits -> testBit bits (pointToIndex (asciiWorldWidth world) point)
        Nothing -> False

inWorldIsPointOverlappingPointsIndexOrMaskIndex :: (Ord k) => AsciiWorld k k -> Point -> k -> Bool
inWorldIsPointOverlappingPointsIndexOrMaskIndex world point key = inPoints || inMask
  where
    inPoints = inWorldIsPointOverlappingPointsIndex world point key
    inMask = inWorldIsPointOverlappingMaskIndex world point key

moveMaskOfIndexBy :: (Ord mk, Ord pk) => mk -> (Int,Int) -> AsciiWorld mk pk -> AsciiWorld mk pk
moveMaskOfIndexBy name (dx,dy) w = w {asciiWorldMasks = M.update (\pts -> Just $ moveMask width (dx,dy) pts) name (asciiWorldMasks w)}
  where width = asciiWorldWidth w

movePointsOfIndexBy :: (Ord mk, Ord pk) => pk -> (Int,Int) -> AsciiWorld mk pk -> AsciiWorld mk pk
movePointsOfIndexBy name (dx,dy) w = w {asciiWorldPoints = M.update (\pts -> Just $ map (movePoint (dx,dy)) pts) name (asciiWorldPoints w)}
  where width = asciiWorldWidth w

addMask :: (Ord mk, Ord pk) => mk -> Mask -> AsciiWorld mk pk -> AsciiWorld mk pk
addMask name mask w = w {asciiWorldMasks = M.insert name mask (asciiWorldMasks w)}

deleteMask :: (Ord mk, Ord pk) => mk -> AsciiWorld mk pk -> AsciiWorld mk pk
deleteMask maskIndex w = w { asciiWorldMasks = M.delete maskIndex (asciiWorldMasks w) }

filterMaskIndices :: (Ord mk, Ord pk) => (mk -> Bool) -> AsciiWorld mk pk -> AsciiWorld mk pk
filterMaskIndices p w = w { asciiWorldMasks = filterKeys p (asciiWorldMasks w) }

filterMasks :: (Ord mk, Ord pk) => (Mask -> Bool) -> AsciiWorld mk pk -> AsciiWorld mk pk
filterMasks p w = w { asciiWorldMasks = M.filter p (asciiWorldMasks w) }

lookupMask :: (Ord mk, Ord pk) => mk -> AsciiWorld mk pk -> Maybe Mask
lookupMask maskIndex w = M.lookup maskIndex (asciiWorldMasks w)

lookupPoints :: (Ord mk, Ord pk) => pk -> AsciiWorld mk pk -> Maybe [Point]
lookupPoints pointsIndex w = M.lookup pointsIndex (asciiWorldPoints w)

adjustMask :: (Ord mk, Ord pk) => (Mask -> Mask) -> mk -> AsciiWorld mk pk -> AsciiWorld mk pk
adjustMask f maskIndex w = w { asciiWorldMasks = M.adjust f maskIndex (asciiWorldMasks w) }

adjustPoints :: (Ord mk, Ord pk) => ([Point] -> [Point]) -> pk -> AsciiWorld mk pk -> AsciiWorld mk pk
adjustPoints f pointsIndex w = w { asciiWorldPoints = M.adjust f pointsIndex (asciiWorldPoints w) }

updateMask :: (Ord mk, Ord pk) => (Mask -> Maybe Mask) -> mk -> AsciiWorld mk pk -> AsciiWorld mk pk
updateMask f maskIndex w = w { asciiWorldMasks = M.update f maskIndex (asciiWorldMasks w) }

alterMask :: (Ord mk, Ord pk) => (Maybe Mask -> Maybe Mask) -> mk -> AsciiWorld mk pk -> AsciiWorld mk pk
alterMask f maskIndex w = w { asciiWorldMasks = M.alter f maskIndex (asciiWorldMasks w) }

copyMask :: (Ord mk, Ord pk) => mk -> mk -> AsciiWorld mk pk -> AsciiWorld mk pk
copyMask srcIndex destIndex w = fromMaybe w $ do
    mask <- M.lookup srcIndex (asciiWorldMasks w)
    return $ w {asciiWorldMasks = M.insert destIndex mask (asciiWorldMasks w)}

copyPoints :: (Ord mk, Ord pk) => pk -> pk -> AsciiWorld mk pk -> AsciiWorld mk pk
copyPoints srcIndex destIndex w = fromMaybe w $ do
    points <- M.lookup srcIndex (asciiWorldPoints w)
    return $ w {asciiWorldPoints = M.insert destIndex points (asciiWorldPoints w)}

applyMask :: (Ord mk, Ord pk, Show mk) => (Mask -> Mask -> Mask) -> mk -> mk -> AsciiWorld mk pk -> AsciiWorld mk pk
applyMask op modifier target w
    | not (modifier `M.member` asciiWorldMasks w) = error $ "applyMask: modifier mask \"" ++ show modifier ++ "\" not found in world"
    | not (target   `M.member` asciiWorldMasks w) = error $ "applyMask: target mask \"" ++ show target ++ "\" not found in world"
    | otherwise = w {asciiWorldMasks = M.insert target newMask (asciiWorldMasks w)}
  where mask1 = case M.lookup modifier (asciiWorldMasks w) of
                    Just m -> m
                    Nothing -> error $ "applyMask: modifier mask \"" ++ show modifier ++ "\" not found (should not happen)"
        mask2 = case M.lookup target (asciiWorldMasks w) of
                    Just m -> m
                    Nothing -> error $ "applyMask: target mask \"" ++ show target ++ "\" not found (should not happen)"
        newMask = mask1 `op` mask2

setPoint :: (Ord mk, Ord pk) => pk -> (Int,Int) -> AsciiWorld mk pk -> AsciiWorld mk pk
setPoint name (x,y) w = w {asciiWorldPoints = M.insert name [(x,y)] (asciiWorldPoints w)}

deletePoints :: (Ord mk, Ord pk) => pk -> AsciiWorld mk pk -> AsciiWorld mk pk
deletePoints name w = w {asciiWorldPoints = M.delete name (asciiWorldPoints w)}

insertMaskFromPoints :: (Ord mk, Ord pk) => mk -> [Point] -> AsciiWorld mk pk -> AsciiWorld mk pk
insertMaskFromPoints newMaskIndex points w = w {asciiWorldMasks = M.insert newMaskIndex newMask (asciiWorldMasks w)}
  where width = asciiWorldWidth w
        newMask = foldl' bitwiseOr 0 $ map (pointToMask width) points

inWorldMaybeInsertMaskIndexFromPointsIndex :: (Ord mk, Ord pk) => AsciiWorld mk pk -> mk -> pk -> Maybe (AsciiWorld mk pk)
inWorldMaybeInsertMaskIndexFromPointsIndex world newMaskIndex pointsIndex = do
    points <- M.lookup pointsIndex (asciiWorldPoints world)
    let newMask = foldl' bitwiseOr 0 $ map (pointToMask width) points
    return $ world {asciiWorldMasks = M.insert newMaskIndex newMask (asciiWorldMasks world)}
  where width = asciiWorldWidth world

isOverlappingMasks :: (Ord mk, Ord pk) => mk -> mk -> AsciiWorld mk pk -> Bool
isOverlappingMasks name1 name2 w
    = fromMaybe False $ do
        points1 <- M.lookup name1 (asciiWorldMasks w)
        points2 <- M.lookup name2 (asciiWorldMasks w)
        
        return $ points1 `isOverlapping` points2


-- Testing
exampleAsciiWorld1 :: AsciiWorld String String
exampleAsciiWorld1 = AsciiWorld (M.fromList [("U",3)]) (M.fromList [("U",[(7,7)])]) 10

exampleAsciiWorld2 :: AsciiWorld String String
exampleAsciiWorld2 = AsciiWorld (M.fromList [("U",96)]) (M.fromList [("U",[(0,6)])]) 10

exampleAsciiWorld3 :: AsciiWorld String String
exampleAsciiWorld3 = exampleAsciiWorld1 `combineTwoAsciiWorlds` exampleAsciiWorld2

exampleAsciiWorld4 :: AsciiWorld String String
exampleAsciiWorld4 = movePointsOfIndexBy "U" (1,1) $ exampleAsciiWorld3

examplePrint1 = printAsciiWorld 10 '.' head head compare exampleAsciiWorld1
examplePrint2 = printAsciiWorld 10 '.' head head compare exampleAsciiWorld2
examplePrint3 = printAsciiWorld 10 '.' head head compare exampleAsciiWorld3
examplePrint4 = printAsciiWorld 10 '.' head head compare exampleAsciiWorld4

exampleOfMaskOperationsHeightHandWorld :: (Int, AsciiWorld String String)
exampleOfMaskOperationsHeightHandWorld = readAsciiWorld (Just . MaskIndex . (:[])) (unlines [".....",".....",".....",".....",".***.","..*..","....."])

exampleOfMaskOperation1, exampleOfMaskOperation2 :: IO ()
exampleOfMaskOperation1 = (\(height,world) -> printAsciiWorld height '.' head head compare world)                   $ fmap (moveMaskOfIndexBy "+" (0,3) . applyMask bitwiseXor "*" "+" . moveMaskOfIndexBy "+" (0,1) . copyMask "*" "+") $ exampleOfMaskOperationsHeightHandWorld
exampleOfMaskOperation2 = (\(height,world) -> print . popCount . fromJust . M.lookup "+" . asciiWorldMasks $ world) $ fmap (moveMaskOfIndexBy "+" (0,3) . applyMask bitwiseXor "*" "+" . moveMaskOfIndexBy "+" (0,1) . copyMask "*" "+") $ exampleOfMaskOperationsHeightHandWorld

printExampleWorld5  = let bgChar = '.'
                          
                          charMap 'X' = Just (MaskIndex "X")
                          charMap 'Y' = Just (MaskIndex "Y")
                          charMap '.' = Nothing
                          charMap  _  = Just (MaskIndex "")
                          
                          
                          inStr = "XYZ"
                          
                          maskToChar  ""   = '-'
                          maskToChar (x:_) = x
                          
                          pointsToChar  ""   = '-'
                          pointsToChar (x:_) = x
                          
                          indexZOrder (PointsIndex _) (MaskIndex   _) = LT
                          indexZOrder (MaskIndex   _) (PointsIndex _) = GT
                          indexZOrder _ _ = EQ
                          
                          (height, world) = readAsciiWorld charMap inStr
                      in printAsciiWorld height bgChar maskToChar pointsToChar indexZOrder world

printExampleWorld5' = let bgChar = '.'
                          
                          charMap 'X' = Just (MaskIndex "X")
                          charMap '.' = Nothing
                          charMap  x  = Just (MaskIndex [x])
                         
                          inStr = "XXXYYIYYYYRRRRRRRRRRRRJJJJJJJJBBBBBBBYYYYYYYYYYYYYEEEEERRRRRRCCCCCCCCCCCCCCCCCAAAAAAAAAAAAGGGGGGGGGGGGGGDDDHHHHHHHHHGRGFFGGVGGMMMMBBBBBBBBBB\nXYXYYYYYYYRRRRRRRRRRRRRRJJJJJJBBBBBBBBYYBYYYYYYYYYYEEEEEERRRRRCCCCCCCCCCCCCCAAAAAAAAAAAAAAGGGGGGGGGGGGGGDDDDHHHHHHGGGRGFGGGGGMGMBMBBBBBBBBBB\nXYYYYYYYYYYRRRRRRRRRRRRJJJJJJBBBBBBBBBYYBBYYYYYYYYYYEEAAARRRRCCCCCCCCCCCCCCCAAAAAAAAAAAAAGGGGGGGGGGGGGGGIDDDHHHHGGGGGGGGGGGGGGGGBBBBBBBBBBBB\nIKKYYIYYYYRRRRRRRRRRRRRJJJJJJBBBBBBBBBBBBBBYYYYYYYYEEEEAARRRRRCCCCCCCCCCCCCCCCAAAAAAAAAAAGGGGGGGGGGGIIIIIDDIHHHGGGGGGGGGGGGGGGGGBBBBBBBBBBBB\nIIKKIIYYYYYRRRRRRRQRRRJJJJJJJBBBBBBBBBBBBBBBYYYYYYYEEEERRRRRRCCCCCCCCVCCCVVICCAAAAAAAAAAAGGGGGGGGGGIIIIIIIIIIIHHGGGGGGGGGGGGGGGGBBBBBBBBBBBB\nIIKKIIYYYYYYRRRRRRRRJJJFFJJJJJJBBBBBBBBBVVBBYYYYYYYEEERRRRRRCCCCCCCCCVVCCVVVVAAAAAAAAAAAAAGGGNGGGGGGIIIIIIIIIIHGGGGGGGGGGGGGGGGBBBBBBBBBBBBB\nIIIIIIYYYYYYYRRRRRJJJJJFFFFJLJJJJBBBBBBBBVBBYYYYYYYYEERRRRRRRCCCCCCCPPVVNVVVWAAAAAAAAAAAAAGGGGGGGNGGGIIIIIIIIHHGGGGGGGGGGGGGGGBBBBBBWBBBBBBB\nIIIIIIIYYYYYYYRRRRJJFFFFFFLLLJJJJJBBBBBBBBGGGYYYYYYYGGRRRRRRRRCICCVVPVVVVVVVVAAAAAAAAAAAAAAGGGGGGNNNNNIIIIIIIIHHHGGGFEEEGGGGGGJJBBBWWBBBBJBB\nIIIIIYIYYYYYYYRRGRJFFFFFFFLSLLLLJJBBBBBGBBBGGGYYYYYYGGRRRRRRRRRICCFVVVVVVVVVAAAAAAAAAAAAAYAYYYYNUNNNNNIMIIIIIIIIHHHGFFFEEGGGGGJJJJJSSBBBBBIB\nIIIIIYYYYYYYYYGRGRJFFFFFFLLLLLLLLJSSSFBGBBBGGGYYYYYGGGFRRRRBRRRRRVVVVVVVVVVVAAAAAAAAAAAAYYYYYYNNNNNNNNIIIBIIIIIHHHHFFEEEGGGEJJJJJSSSMMSBBMSS\nIIIIIIYYYYYYYYYRGRFFFFFFLLLLLLLLSSSSSSGGGGGGGGYYGYGGGGGGRWRRRRRRRVVVVVVVVVVVVVAAMAAAAAAAAYYYYYNNNNNNNNNIIIIIIIIHHHHFFFEEEEGEJJJJJSSSSSSSSSSS\nIIIIIIYYYYYYYTYRFFFFFFFFFFFLLLLRRRSSSSGGGGGGYYYYGGGGGGGGGRRRRRRRVVVVVVVVVVVVGGAAAAYAAAAAAYYYYYNNNNNNNNNNNIIIIIOHHHHFFEEEEEEEJJJJJJSUSSSSSSSS\nIIIIIIIYYYYYYTTTFFFFFFFFFFFLLRLRRRJSSSGGGGGGGYGGGGGGGGGGAAARRRRRRVVVVVVVVVVIYYYYYYYAYYYAAYYYYNNNNNNNNNNNNIIIIIHHFHFFFEEEEEEEETJJJJSUTSSSSSSS\nIIIIIIIYYYYYYYTTFFFFFFFFFFFLFRRRRJJSGGGGGGGGXGGGGGGGGGGGAAAAARRVVVVVVVVVVVVIYYYYYYYYYYYYYYYYYNNNNNNNNNNNNIIIFFFFFFFFEEEEEEEETTTTTTTUTSSSSSSS\nIIIIIIIIYYYYYTTTFFFFFFFFFFFFFFRRRRJGGGGGGGGXXXXGGGGGGGGGAAAAQQQQQQQGGEEVVVVVYYOYYYYYYYYYYYYYYYNNNNNNNNNNNNNIFNNNFFFVVGGEEEEETTTTTTTTTTTSSSSS\nIIIIIIIIYYYYYTTTFFFFFFFFFFFFFJJJJJJJGGGGGXXXXXXXGGGGGGGGGAAQQQQQQQQGGEEAVVVVVOOOYYYYYYYYYYYYEYEEANNNNNNNNNNNNNNNFFFVVVGEEEEEEETTTTTTPTSSSSSS\nIIIIIIIIYYYTTTFFFFFQQFFFFFFFJJJJJJGGGGGXXXXXXXXGGGGGGGGDQQQQQQQQQQQQQEEEEOOOOOOYYYYYYYYYYYYYEEEEESNNNNNNNNNNNNNNFFFVVVVVVEEEEKTVTTTTTTSSSSSS\nIIIIIIIYYYYYYYQQIFSQQFFFFFFJJJJJJJJGGGGGXXXXXXXGGGGGGGGDMQQQQQQQQQQQEEEEEOOOOOOOOYYYYYYYEEEEEEEEEENNNNNNNNNNNNNNFFFVVVVVVVDEEVQVTTTTSSSSSSSS\nIIIIIIYYYYKYQZQQQQQQQQQFFJJJJJJJJJJJJGGGXXXXXXXGGGSSSSGDDQQQQQQQQQQEEEEEEOOOOOOYYYMMMEEEEEEEEEEEEEFFFNNNNNNNNNNFFFVVVVVVVVVRRVVVTTTTTXSXXXXS\nIIIIUUUYUQQQQQQQQQQQQQFFJJJJJJJJJJJJJGGJXXXXXXXGGGGGDDDDDQQQQQQQQQLVEEEEEOOOOJJJYYYMMEEEEEEEEEEEEEFFFFFFFNNNNFFFFVVVVVVVVVVVVVVVTTDTXXXXXXXX\nIIUUUUUYUUQQQQQQQQQQQFFFJFJYYJYJJJJJJJJJJXXXXXXGGGGGDDDDDDQQQQQQQLLEEEEEEEOOOJJJZZZMMEEEEEEEEEEEEEEEEFFFFFNNFFFFFVFVVVVVVVVVVVVVTTDXXXXXXXXX\nIIUUUUUUUFIIIQQQQQQQQQFFFFPYYYYJJJJJJJJJJVXNNNNNGGGCDDDDDDLDDWWWQLLEEEEEEEOOOOJZZZZMMMEEEEEEEEEEEEEEIZZZZFNFFFFFFFFFVVVVVVVVVVVVQXXXXXXXXXXX\nIUUUUUUUUFFIIIQQQQQQQQQFFYYYYYYJJJJJJJJJJVDDNNNNGGTCDDDDDDDDDDWQQLLLLEEEEEOOOOOKKZZZMMEEEEEEEEEEEEEWZZZZZFFFFFFFGFFFFVVVVVVVVVVVXXXXXXXXXXXX\nUUUUUUUUFFIIIIIQQQQQQQIFFFYYYYZJJJJJJJJJZDDDDNDNNCCCDDDDDDDWWWWWWLLLLLFEEEZZZOZZZZMMMMMEMEEEEEEEIIEWZZZZZZFFFFFGGFFFVVVVVVVVVVVVXXXXXXXXXXXX\nUUUUUUUUUFIIIQQQQQQQIIIIIIIYYYZZJZJJJJJJZDDDDDDCCCCCCDDDDDWWWXXXWLLLLLFFEEZZZZZZZZZMMMMMMELEEEEIIIZZZZZZZZFFFFFFGGGGVVVVVVVVVVVVXXXXXXXXXXXX\nUUUUUUUUBBBIIQQQQTTTIIIIIIIYYYZZJZJJJJJZZZDDDDDDDCCCCCDDDDDWXXXXLLLLLLLFXXZZZZZZZZZMMMMMMEEEEEEIIIZZZZZZZZZZZZGGGGGGVVVVVVVVVVVVXXXXXXXXXXXX\nUUUUUUUUBBBBBLQQQTTTTIIIIIYYYYYZZZZZJJJZZZDDDDDDDCCCCCDCDDDDXXXXLLLLLLLFXXXZZZZZZZZMMMMMMEEEEEEIIZZZZZZZZZZZZZJJGGGGGVVVVVVVVVVMMXXXXXXXXXXX\nUUUUUUUUUUBBBBQQWTTWTIJIIYYYYYYZZLZZJJZZZZDDDDDDDDCCCCCCCDDDXXXXXLLLLLLFXZZZZZZZZZZMMMMMMMMEEEIIIZZZZZZZZZZZZZJJJJGGJVVHUVVVVVVMMXXXXXXXXXXX\nUUUUUUUUUHBBBBJWWWTWWIJJIYYYYYYZZZZZZZZZZZDDDDDDDDCCCCCCCCDDXXXXXXXLLLXXXXXZZZZPPPPPPPPPPPPPPIIIIIIZZZZZZZZZZJJJJJJJJVJUUVVVVMMMMXXXXXXXXXXX\nUUUUUUUUUHHHOWWWWWWWJJJJJJYYYYYZZZZZZZZZZZDDDDDCCCCCCCCCCCDDXXXXXXXLXXXXXXXXZZZPPPPPPPPPPPPPPMIIIEEAZZZZZZZZZZZZJJJJJJJUUMMMMMMMXXXMMXXXXXXX\nUUUUUUUUUHHHWWWWWWWWWWJJJJJYYYZZZZZZZZZZDDDDDDDCCKCCCCCCCCDDXXXXXXXXXXXXXXXXZZZPPPPPPPPPPPPPPPPPPPPPPZZZZZZZZZZZJJJJUUUUUMMMMMMMMMMMMMMMXMME\nUUUUUUUUHHHHWWWWWWWWWEEEEEEEEYPZZZZZZZZZDDDDDDDDDDCCCCCCCCDDXXXXXXXXXXXXXXXXXZZPPPPPPPPPPPPPPPPPPPPPPZZZZZZZZZZZJJJJUUUUUUMMMMMMMMMMMMMMMMMM\nBUUUUUUUUHHHWWWWWWWWEEEEEEEEPPPZZZZZZZZZZDDDDDDDDDDCMMMCJMMDMXXXXXXXXXXXXXXXEZZPPPPPPPPPPPPPPPPPPPPPPEEEZZZZZZZZJJJUUUUUUUMMMMMMMMMMMMMMMMMF\nBBBUUUUUUHHHWWHWWDWWEEEEEEEEPPPZZZZZZZZZDDDDDDDDDDDMMMMMMMMDMMXXXXXXXCXXXXXXEZZPPPPPPPPPPPPPPPPPPPPPPEEEZZZZZZZZZZJJUUUUUWMMMMMMMMMMMEEMMMMF\nBBBGTBBBBBBBBHHWDDEWEEEEEEEEPPPZZZZZZZVVDDDDDDDDDDMMMMMMMMMMMMXXXXXCXCCCCXXXEZZPPPPPPPPPPPPPPEEEEEEEEEEEEESZZZZZZZJJJUUUUWMMMMMMMMMMMEEEMMMF\nGGGGGBBBBBBBBHLWDDEWEEEEEEEEPZZZZZZZZIDDDDDDDDDDDMMMMMMMMMMEMYYYXXXCCCCCCXCZZZZPPPPPPPPPPPPPPPEEEEEEEEEEESSSZZZZZJJJJUUUUWWWMMMMMXXXEEEEEEEF\nGGGGGBBBBBBBBHHDDEEEEEEEEEEEEZZZZZZZZZCCDDDDDDDDMMMMMMMMMMMEYYXXXXXCCCCCCCCCZZWPPPPPPPPPPPPPPPEEEEEEEEEESSOOOZZJJJJJJJUUUUMMMMMMXXXXEEEEAAAA\nGGGGGBBBBBBBBHEEEEEEEEEEEEEEDDDDZZZZZZCCCCDDDDDDDMMLLMDMMMJYYYYJJXXCCCCCCCWWWWWWWZZPPPPPPPPPPPEEEEEEEEEEESOOIIJJJJJJJJUUJUMMMMMMXXXXXEEEEEEA\nGGGGGBBBBBBBBEEEEEEEEEEEEEDDDDDDZZZZZICCCCCFDDDFDMLLLLMMMJJJJJJJJXXCCCCCWWWWWWWWZZZPPPPPPPPPPPMMEEEEEEESSSOOIIIJJJRJJJJJJJMMVMMXXXXXEEEEEEAA\nGGGGGBBBBBBBBREEEEEEEEEEEEDDDDDDZZCCCCCCCCCFFSSFMMLLLLLMMMMMJJJJJXXCCCCCCWWWWQQQQQZPPPPPPPPPPPZZZEEESSSSOOOOOOOJJJRJJJJJJJVVVVMXXXXEEEEEEEAA\nGGGGGGGGBBBBCRREEEEEEEDDEEDDDDDDDZZOCCCCCCCFFFFFMMLLLFMMMMKKJJJJJCCCCCCCCWWWQQQQQQZPPPPPPPPPPPZZZZSSSSSOOOOOOOOOJJRRJJJJJVVVVVVVVXEEEEEEEEEA\nGGGGGGAABBBBRRRRRRRRDDDDDDDDDDDDDCCCCCCCCCCFFFFFFFFFFFJMMMKKKKJJJJCCCCCCWWQQQQQQQQQPPPPPPPPPPPZZVVVVSSOOOOOOOORRRRRRRRJJJVVVVVVVVBEEEEEEEEAA\nGGGAAAAABBBBRRRRRRDDDDDDDDDDDDDDDCCCCCCCCCCCCFFFFFFFFQQQMKKKJJJJJJJJCCCCWQQQQQQQQQQZZZZZZZZPPPZZTVVSSOOOOOOOOORRRRRRRRJJJVAAVVVVVBEEEEEEEEEA\nGGAAAAAAAAAARRRRRDDDDDDDDDZZZZDZZZCCCCCCCCCCCFFFFFFQQQQQQKKKJJJJJJJJCWCWWQQQQQQQQQQQZQVVZZZPPPVVVVVOOOOOOOOOOORRRRRRRRRRJVVVVVVVVVMEEEEEEAAA\nGGAAAAAAAARRRRRRRRDDDDDDDZZZZZZZZCCCZCCCCCCCCFFFFFFFQQQQQKKKJJJJJJJJWWWWHHQQQQQQQQQQQQQQZHQPPPZVVVVVKOOOOOOOOOORRRRRRRRRVVVVVVVVVVVVEEEEEAAA\nGAAAAAAAAARRRRRRRRDDDDDDDZZZZZZZZZZZZCCCCCCCFFFFFFFFFQQQQQKKJWJJJJJJJWWHHHQQQQQQQQQQQQCQQQQQZGZQQVVVVOOOOOOOOOORRRRRRRRRVVVVVVVVVVVVVEEEAAAA\nGAAAAAAAAARRRRRRRRDDDDDDZZZZZZZZZZZEZCCCCCCFFFFFFFFFFQQTTTWWZWJWJWJWWWWHHHQQQQQQQQQQQQCQQQQQZZZQVVVVVVOOOOOORRRRRRRRRRRVVVVVVVVVVVVAAAAEAAAA\nGGAGAAAAAARRVVRRRRDDDDDDZZZZZZZZZZZECCBCCCCCFFFFFFFFJQQQWWWWWWWWWWWWWWWHHHHHQQQQQQQQQCCQQQQQQQQQQQVVVVVOOOORRRRRRRRRRRRRVVVVVVVVVVVAAAAAAAAA\nGGGGAAAAAAAAAVRIDDDDDDDDZZZZZZZZZZZBQBBBCCFFFTFFSFFFJQKKKWWWWWWWWWWWWWHHHHBQQQQQQQQQQQQQQQQQQQQQQQQVVVVOOOOOOOORRRRRRRXRRRVVVVVVVVAAAAAAAAAA\nGGWWAAAAAAAAAAIILDDDDDDDJZZZZZZZZZZBBBBBCCFFFFFFSEEEEEKKKKWWWWWWWWWWWHHHHHHQQQQQQQQQQQQQQQQQQQQQQQQQSVVOOIOIOOOWRRRRRRXRRVVVVVVVVVVAAAAAAAAA\nWWWWAAAAAAAAAIIILLDDDDDAAXZZZZZZZZBBBBBBBCCCCFCCEEEEEKKKKKWWWWWWWWWWWHHHHHHHQQQQQQBQQQQQQQQQQQQQQQQQQVOOOIIIIOWWRUXXXRXRRVVVVVVVVVVVVAAAAAAA\nWWWAAAAAAHAAAFFFFFFFFAAAAAZZZZZZZBBBBBCCCCCCCCCCEEEEEEKKKKWWKKRWWRRRHHHHHHHHQQQQQQBQQQQQQQQQQQQQQQQAQOOOOIIIOOWWWUXXXXXXXVVVVVVVVVVAAAAAAAAA\nWWNNFAAAAHHHHFFFFFFFFAAAAAZZZZZZZBBBBBBCCCCCCCCCEEEEEEKEKKWKKKRRRRRRRPPCCHHCCCCCQBBBHHQQQQQQQQQQQQOODOOOOIIIWWWWWXXXXXXXXVVVVVVAAAAAAAAAAAAA\nNNNNNAAAAXHHHFFFFFFFFAAAAAAZZZZZZZZZBBBCCCCCCCECZEEEEEEEKKKKKKRRRRRRRPPCCCCCCCCCCBBBHHHQQQQQQKQQQMOOOOOOOOWWWWWWWXXXXXXXXVVAAVVAAAAAALAAALLA\nNNQNNAAAASSSSFFFFFFFFFFFFFAAAAZZZZBBBBBCCCCECEEEEEEEEEEEEKRRRRRRRRRRRPPCCCCCCCCCCBBBBHHHHHQQQQQMMMMMMOOOOWWWWWWWWXXXXXXXXXVAAAAAAAUALLAAALLL\nNNNNNQNNNSSSIFFFFFFFFFFFFFAAAAZZZZZBBBBCCCCEEEEEEEEEEEEEEKRRRRRRRRRRRPPPCCCCCCCCCHBBHHJHJJJMQMMMMMMMMOOYOYWWWWWXXXXXXXXXXXAAAAAAAAALLLLLLLLL\nNNNNNNNNNYFFFFFFFFFFFFFFFFAAAAZZZZBBLBBCCEEEEEEEEEEEEEEKKKRRRRRRRRRRQQQQQCCCCCCCHHBBHHJJJJMMMMMMMYYMMMYYYYYYWWWWXXXXXXXXXXAAAAAAAAALLLLLLLLL\nNNNNNNNNNNFFFFFFFFFFFFFFFFAAAAAAAZZMLLMCCCEEEEEEEEEEEEEEKKRRRRRRRROOQQQQQCGCCCHHHHHHHHHJJJMMMMMMMYYYYYYYYYYYWWWWXXXXXXXXXLLLLLLLLLLLLLLLLLLL\nNNNNNNNNNYFFFFFFFFFFFFFFFFAAAAAAAAAMMMMEEEEEEEEEEEEEEKKKKRRRRRRRRRQOQQQQQQGCCCCHHHHHHJHJJJMMMMMMMYYYYYYYYLLYJNWWWXXXXXXXXLLLLLLLLLLLLLLLLLLL\nNNNNNNNNNNFFFFFFFFFFFFFFFFAAAAAAAIMMMMMMBEEPEEEEEEEEEEKKKKRRRRRRRXQQQQQQQGGCCCSSHHHHJJJJJJJMMMMMMMYYYYYYYYYNNNNWXXXXWXWWWLLLLLLLLLLLLLLLLLLL\nOOONNNNNYYFFFFFFFFFFFFFFFFAAAAAMMMMMMMMMMBBBEEEEEEEEEEKKKKRRRRRQQQQQQQQQQCCCCCSSHHHHHJJJJJJJMMMMMMYYYYYYYYNNNNNWWWWXWWWWWLLLLLLLLLLLLLLLLLLL\nOOONNNNYYYFFFFFFFFFFFFFFFFAMMMMMMMMMMMMMBBBBBEEBEEBEEEKKKKRRRRRRRRQOQQQQQQCCPCPSHHHHHJUJJJJJJMMMMMYYYYYYYYNNNNWWWWWWWWWWWLLLLLLLLLLLLLLLLRRL\nOOOONNJJYYFFFFFFFFFFFFFFFFAMMMMMMMMMMMMMBBBBBBBBEBBBEEKKKKKRWWWRRRROOOSSSSCCPPPSSHHHHJJJJJJJJJMMMMMYFYYYYNNNNNNWWWWWWWWWWLLLLLLLLLLLLLLLRRRL\nOOOONNNJJJDDDDDDFFFFFFFFFFFFFDDMMMMMMMMMMMBBBBBBEBEBEEKKKKWWWWWWOORROOSVSSPPPPSSSSSSSJVJJJSRRMMMMMMYYYYYNNNNNNNNNWWWWWWWWLLLLLLLLLLLLLLLRRHH\nNNNNNNNDDDDDDDDDDDDDLLLLFFFFFDDMMMMMMMMMMMBBBBBBBBEEEEEKKWWWWWWWOOOOOOSSSSSPSSSSSYSSSVVJJJSRRRMRMRRNNNYNNNNNNNNNWWWWWWWNNLLLLLLLLLLLLLLHHHHH\nNNNNNNNDDDDDDDDDDDDDDDDDFFFFFDDMMMMMMMMMMMMMMMMBBBBBBBEEKWWWWWWWOOOSSSSSSSSSSSSSSSKSSVVVJSSRRRRRRRRNNNNNNNNNNNNNWWWWWNWNNLLLLLLLLLLLLLHHHHJH\nNNNNNNNDDDDDDDDDDDDDDDDDFFFFFDDRRMMMMMMMMMMMMMMBBBBBBBBEWWWWWWWWXXSSSSSSSSSSASSSSSSSSRRVVRRRRRRRRRRXNNNNNNNNNNNNWWWNNNNNNNNLLLLLLLLLLLHHHHJH\nNNNNNJJJJJJJJJJJJDDDDDDDFFFFFDDRRMMMMMMXXXXXXMMMXXXBBBBBWWWWWCCWXXSSSSSSSSSSSSSSSSSSSRRVVRRRRRRRRRRRNNNNNNNNNNNNWWWWNNNNNNNLLLLLLNNNNNHHHHHN\nNNNNJJJJJJJJJJJJJDDDDDDDFFFFFDDYRRMSMMMXXXXXXBMMCXXBXXBBWYWWWCCXXXCSSSSSSSSSUUUUUSSSSRRRRRRRRRRRRRRNNNNNNNNNNNNNWWWWNNNNNNNLLLLLLNNNNNNHHHHH\nJJJJJJJJJJJJJJRJJDDDDFFFFFFFFDDYRRMMMMMXXXXXXXXXXXXBXXBXYYWWCCCXXXCCSSSSSSSSUUUUUSSSSRRRRRRRRRRRRRRNNNNNNNNNNNNWWWNNNNNNNNNLLLLLLPPPPPNNHHFH\nJWWWWWWWWJJJJRRRJDDDDFFFFFFFFDDYRRRMMMMXXXXXXXXXXXXXXXXXXXCCCCCCXXXCSSSSSSSSUUUUUSSSSSRRRRRRRRRRRRNNNNNNNNNNNNNNNWWNONNNNNNLLLLLLPPQQHHHHHFF\nJWWWWWWWWJJJRRRRRLYYYFFFFDDDDDDYRRRRRRXXXXXXXXXXXXXXXXXDXXCCCCCXXXCCCSSSSSSSUUUUUSSSSDKKKRRRRRRQRRRDNNNNNNNNNNNNWWWWNNNNNNNLLLLLLPPPQQFHHHHF\nJJWWWWWWWWWJRRRRRRYYYFFFFFDDDDDRROOOOOOOOOXXXXXXXXXXXXXXXXCCCCXXXXCCCCSRRRSSUUUUUSSSSDKRRRRRRRRDDDDDDNNNNNNNNNNSWWSWNRNRNNNLLLLLLPPSFFFHFFFF\nJWWWWWWWWWRRRRRRRRRRYFFFFFDDDDDYYOOOOOOOOOXXXXXXXXXXXXXXXXCCCCCCCCCCCCCFFRSKUUUUUDDDDDDDDRRRRRRDDDDDDDDDDDNNSSSSSSSSSRRRNNNNPPPPPPPSFFFHFFFF\nJWWWWWWWWWRRRRRRRRRRYFFFFFDDDDDYROOOOOOOOOXXXXXXXXXXXXXCCCCCCCCCCCCFFFFFFRRSUUUUUDDDDDDDDDDDDRRDDDDDDDDDDDDDDDSSRRRRRRNNNNNWWPPPPPPPFFFFFFFF\nWWWWWWWWRRRRRRRRRRRYYFFFFFDDDDDRROOOOOOOOOXXXXXXXXXXXXXXCCCCCCXCCCCFFFFFFRSSUUUUUMDDOIDDDDDDDDDDDDDDDDDDDDDDDDSSRRRRRRRNNNNWWWPTPPPPPFFFFFFF\nWWWWWWWWWRRRRRRRRRRRYFFFFFDDDDDOROOOOOOOOOXEEVEXXXXXXXXXXCXXXXXXCCCFFFFFFFOSUUUUUMMDIIDDDDDDDDDDDDDDDDDDDDDDDDDPPPRRRRRRRRRTTTTTPPPPPFFFFFFF\nXXWWWWWWWRRRRRRRRRRRYYFFFFDDDDDRROOOOOOOOOXEEVEEEXXXXXXXXCXXXXXCCCCCCFFFFFFGGGSSMMMDIIDDDDDDDDDDDDXDYYDDDDDDPPPPPPRRRRRRRRRTTTTTTPPPPFFFFEFF\nXXWWWWWWWRIIRRRRRRRKJJFFFFFFFFORROOOOOOOOOXEEEEEEXXXXXXXXXXXXXXXXFCFFFFFFFFFGGGMMMMMIIIDIIDDIDDDDDDDYYDDDDYDPPPPPPRRRRRRRRRTTTTTTTPPEFFFEEEE\nXWWWWWWWWIIRRRRRRRRROJFFFFFFFFOORRRRRRRREEEEEEEEEXXXXXXXXXXXXXXFFFFFFFFFFFFFFGMMMMMIIIIIIIDIIDDDDDDFYYYDDDYPPJPPPPRPPPRRRRRRRTTTTPPPEEFEEEEE\nXXDDWWWWWWIRRRRRRRJJJJFFFFFFFFOOOOORRRRREEEEEEEEEEXXXXXXXXXXXXXXXFFFFFFFFFIGGGMMIIIIIIIIIIIIIIDDFFFFYYYYYYYYYJYPPPPPPPPRRRRTTTTTTTTEEEEEEEEE\nDXDDDDWWWWIRRRRRSRJJJJFFFFFFFFOOOOOORRREEEEEEEEEEEHXHXXXXXXXXXXFFFFFFFFFFGGGGGMMIIIIIIIIIIIIIIKKFYYYYYYYYYYYYYYPPPPPPPRRRRTTTTTTTTTEEEEEEEEE\nDDDDDDDWWWRRRRRRRRJJOOFFFFFFFFOOOOMMRKREEEEEEEEEEEEVVVXXXXXXXXXXFFFFFRRRRGGGGGMMMIIIIIIIIIIIIIIKKYYYYYYYYYYYYYPPPPPPPRRRRRRTTTTTTTTEEEEFEEFE\nDDDDDDDWWWRRRRRRRRJJOOOOOOOOOOOOOOMMMEEEEEEEEEEEEVVVVIVXXXXXXXXXXXFFRRRRRRRRRXIIIIIIIIIIIIIIIKKKUYYYYYYYYYYYYYPPPIIORRRRRRRTTTTTTTEEGFFFFFFE\nDDDDDDWWWWWRRRRRRJJJJJOOOOOOOOOOOOONNLLLWWEEEEEEEVVVVVVFXXXXXXXXXXRFRRRRRRRRRXIIIIIIIIIIIIIIIKKKKKYYYYYYYYYYYYYYOOOOORRRDRRDDTTTTTTGGPFFFFFF\nDDDDDDDDWWWWWZZJJJJJJJJJOOOOOOOOOSONNWWWWWWEWEEVVVVVVFVFFFFXXXXXXXRRRRRRRRRRCRRIWIIIIIIIIIIIKKKKKKYYYYYYYYYYYYYYYGGORRRRDDDDDGGTGTTAGGFFFFFF\nDDDDDDDDDWWZZZZZZJJJJJJJOOOOOOOONNNNNNNWNWWWWEVVVVVVVFFFFFFXXXXXXXRRRRRRRRRRRRREIIIEIIIIIIIIKKKKKBBYYYYYYYYYYYYRYSGSSSRDDDDDDGGGGGGGGGFFFFFF\nDDDDDDDDDWZZZZZZZJJJJJJJJIOOOOOOOONNNNNNWWWWWWVVVVVVVFFFFFFFXXFXXXRRRRRRRRRRRREEEEEEIIIIIIKKKKKKKKYYHYYYYYYYYYHSSSSSSSSSDDDDDDGGGGGGGGFFFFFF\nDDDDDDWWWWWWZZZZZZZJJJJJJIOOODOOOOOFNNNNWWWWWWVVVVVVVFFFFFFFFFFXOOOOOOOORRRRRRRREEEIIIIIIIIIKKKKKKYYHYYYYYYYYHHSHSSSSSSSFDDDDDDGGGGGFGFFFFFF\nDDDDDDWWWZZZZZZZZZZZZJJJJIOOOOOFFOOFFNNNWWWWVWVVVVVVVFFFFFFFFFFXOOOOOOOORRRRRREEEEEEEIIIIIIKKKKKKKKKKYYYYYYYYHHHHSSSSSSSDDGDDSSGGGGGFFFFFFFF\nDDDDDDDDWWZZZZZZZZZZZZZIIIOFFFFFFFFFFOOOWWWVVVVVVVVVVFFFFFFFOOOOOOOOOOOOROOORROOOOEEEEIIIIIKKKKKKKKKKYYYYYYYYYHYSSSSSSSSGGGDDNSGGGGGUUFFFFFF\nDDDDDDDWWWZZZZZZZZZZZZBIIIOFFFFFFFOOOOOOZZVVVVVVVVVVVFFFFFFFOOOOOOOOOOOOROOOOOOOOOOEKEIKIIKKKKKKKKKKKYYKYYYYXYYYYSSSSSSGGGGGNNSGJJLLLLLFFFFF\nDDDDDDDWWZZZZZZZZZBBBBBBBBBFFOOOOOOOOOOOVVVVVVVVVVVVFFFFFFFFOOOOOOOOOOOORQQQAOOOOOOOKKKKKKKKKKKKKKNKKKYNYYYXXYYYSSSSSSSGGGGGNNLLLLLLLLLFFFFN\nDDDDDDWWWWWZGGGZZZBBBBBBBOBOOOOOOOOOOOOOOOVVVVVVVVVVFFFFFFFFOOOOOOOQQQQQQQQQAOOOOOOOKKKKKKKKKKKKNNNKKKKNNNNNXXYYXSSSSSSHGGGGNNNNLLLHLLLLGGFF\nDDDDDDDWWWWWGGGZZZBBBBBBBOBOOOOOOOOOOOOOOVVVVVVVVVFFFTTFFFFFOOOOOOOQQQQQQQQQQOZOOOOOOKFKKKKKKKKKKKNNNNNNNNNNXXYEXXXXXSXHHHHGHNLLLLLLLLLLLLFF\nDDDDDDDWWWWWWWGZBBBBBBBBBBBBBOOOOOOOOOOOOVVVVVVVVVVVVTTFFFFFOOOOOOOQQQQQQQQQQZZZOOOZOOKKKKKKKKKKKKNNNNNNNNXXNXXEEXXXXXXHHHHGHNNLLLLLLLLLBBBB\nDDDDDDDDWWWWWWGGBBBBBBBBBBBBBBOOOOOOOOOOOVVVVVVVVVVKFFFFFFFFOOOOOOOQQQQQQQQQQZZZZZZZZOBKKYKKKKKKSKNNNNNNNNNNNXXXEEXXXXHHHHHHHHNNLLLLLLLRRBRB\nDDUUDDDDWWWWWWGGNBBBBBBBBBBBBOOOOOOOOOOOKVVVVVVVVVKKKKALLLLLLAAAQQQQQQQQQQQQQZZZZZZZZUUYYYYKMMMKKKNNNNNNNNNNNXXXXXXXHHHHHHHHHNNNNLLLLLRRRRRR\nNDDDDDDDWWWWWWWWBBBBBBBBBBBBBBBOOOOOOOOOKKVVVVVVVVKKKZFLLLLLLFHHQQQQQQQQQQQQQZZZZZUUUUYYYYYLMMLLNNNNNNNNNNNNXXXXXXXHHHHHHHHHNNNNNLNLRRRRRRRD\nNDFFDDDDDWWWWWWMMBBBBBBBBRBBBBUOOOOOOOOOKKKKVVVVVKKKKKKLLLLLLFHHHQQQQQQQQQQQQZFFZZUUUULLLLYLLLLLLNNNNNNNNNNAXUXXXXXXXXHHHHHNNNNNNNNLRRRRRRDD\nNDMFFDWWWWWMMMMMMMBBBMMBBBBGOOOOOOOOOOOOOKKKKKKVVVKKKKKLLLLLLLLHQQQQQQQQQQQQQQYFUUUUUUFLLLLLLLLLNNNNNNNNNUUUUUUUXXXXXXHHHHHHNNNNNNRLRRRRRRRD\nMMMMFDWWWWWMMMMMMMXXMMMMBKMOOOOOOOOOOOOOOKKKKKKKKKLLLLLLLLLLLLLHQQQQQQQQQQQQUFFFFUUUUQQQLLLLLLLNNNNNNNNNNUUUUUUUUXXXXHHHWWWNNNNNNNRRRRRRRCDD\nMMMMMWWWWWWWMMMMMMMMMMMMMMMEOOOOOOOKKKKKKKKKKKKKSSLLLLLLLLLLLLLHHHHQQQQQQQQQFFFFFFFFLQQBQQLLLLLLLLNNUNNUSUUUUUUUUUXXXHWWWWWNNNNNNNNRRRRRRCCD\nMMMMMMWWWWMMMMMMMMMMMMMMMMMOOOOOXXOOOKKKKKKKKKKKSSLLLLLLLLLLLLLHHHHHQVQCFFQQQQFFFFFFFQQQQQLLLLLLLLNSSSSSSSUUUUPUUUXXXXWWWWWWWNNNNNNNRRRRRRCC\nMMMMMMMMWWWWWMMMMMMMMMMMMMMMOOFOOVVOKKKKKYYYYYYYYYLLLLLLLLLLLLLHHHLLVVLLFFFFQFFFFFFUQQQQQQLLLLLLLLNSSSSSSSUUUUUUUUXXXWWWWWWWNNNNNNNNNNCRRCCC\nMMMMMMMWWWWWWMMMMMMMMMMMMMMMMPPPPVVVKKKKKYYYYYYYYYLLLLLLLLLLLLLHLLLLLLLFFFFFFFFFFFFFQQQQQQQLLLPPLLGSSSSSSSUUUUUUUUVXXXXWWWWWNCNCNNNNCCCCCCCC\nMMMMMMMMWWMMMMMMMMMMMMMMMMMMMMPPPVIUKKKKUYYYYYYYYYLLLLLLLLLLLLLLLLLLLLLFFFFFFFFFFFJJQQQQQQLPPPPPLLUSSSSSSSUUUUUUUUXXXXXZWWWNNCCCNCNCCCCCCCCC\nMMMMMMMMMMSSSMMMMIIIIMMMMMMMMPPPPPUUUUUUUYYYYYYYYYLLLLLLLLLLLLLLLLLLLLLFFFFFFFFFFFQQQQQQQPPPPPPPUUUSSSSSSSUUUUUUGGXXGXZZZZZCCCCCCCNCCCCCCCCC\nMMMMMMMMMMSSMMIIMIIIIMMMMPPMPPPPPUUUUUUUUYYYYYYYYYLLLLLLLLLLLLLLLLLLLLLLLFLFFFFFFQQQQQQQQPPPPPPPUUUSSSSSSSUUUUUGGGXTGGGGZZZZCCCCCCNCCCCCCCCC\nMMMMMMMMMMSSMMIIIIIIIMSSSSSPPPPPPUUUUUUUKYYYYYYYYYLLLLLLLLLLLLLLLLLLLLLLLFLSSFFFQQQQQQBPQPPPPPPPPPPSSSSSSSUUVUGGGGGGGGGGGGZZCCCCCCCCCCCCCCCC\nMMMMMMMMMMIIIIIIIIIIIMSSSSSSSSSSSSHUUUUUUYYYYYYYYYYYYYSSSSSLLLLLLLLLLLLLLLLSFFVFYYQQYYPPPPPPPPPPPPTUUUUUUUUUVUGGGGGGGGGGGGGZZCCCCCCCICCCCCCF\nMMMMMMMMMTTIIIIIIIIIIISSSSSSSSSSSSUUUUUUUYYYYYYYYYYSSCSSSSSLLLLLLLLLLLLXLSSSDDFFYYQYYPPPPPPPPPPTTTTTVVUUUUUUVVGGGGGGGGGGSSGZCCCCCCCCCLCCCCCC\nQMMMMMMMMMIIIIIIIIIIIISSSSSSSSSSSSUUUUUUUYYYYYYYYYYCCCCSSSSLLLLLLLLLLLLLSSSSSSFYYYYYPPPPPPPPPPTTTTTVVVUVVVVVVGGGGGGGGGGGGGGZCCCCCCCCCCCMYYYM\nQMMMMMMMMMMIIIIIIIIIIISSSSSSSSSSSSUUUUUUUYYYYYYYYYYCCCCCSSSZSSSLLLNNNLLLNSSNSHHFFFFFFFFFPPPPPPTTTTTVVVVVQVVVVVGGRRGGGGGGGGCCCCCCCCCCCCMMMYMM\nQMMMMMMMMMMMIIIIIIIIIISSSSSSSSSSSSWUUUUUUUUUUCCCSCCCCCCCSSZZSSSLLLNNLLNNNNNNYYYFFFFFFFFFPPPPPBTTTTTTTVQQQQQQVVVGRRRGGGGGGGGRCCCCCCCRCCJMMMMM\nQQQMMQQQMMQQIIIGIIIIIISSSSSPPPPPPPWUUUUUUUUUUCXCCCCCCCCCCSSSSSSLLNNNLLNNNNNNNFFFFFFFFFFFPPPPTTTTTTTTTTIQQQQQQRGGRRRRRBBBBBBRRCCCCCCRRMMMMMMM\nQQQQQQQQMQQRIIRGIIIIIISSSSSPPPPPPPPPUUUUUUWUCCXXXCCACCCCCCSSSSSLNNNNNNNNNNNNYFFFFFFFFFFFPTTTTTTTTTTTQQQQQQQQQRGGGGRRRBBBBBBRRCCCRMMRRRMMMMMM\nQQQQQQQQQQQRRRRGIGGIIISSSSSPPPPPPPPPPLUUUUXXXXXXCCCACCSCSSSSSIIIIIIIIINNNNNYYFFFFFFFFFFFPTTTTTTTTTTTTTTQQQQQRRPPRRRRRBBBBBBRRCRRRMMRMRRRMMMM\nQQQQQQQQQGGGGRRGGGGKKKKZJJPPPPPPPPCCPUUUUUXXXXXXXXCASSSSSSSSSIIIIIIIIINNEEEYYFFFFFFFFFFFTTTTTTTTTTTTTTPPQQQQRRPPNRRRRBBBBBBRRRRRRRMMMRRRRMMR\nQQQQQQQQQGGGGGGGGGGKKKKZZZMMMPPPPDCCCUUUUUXXXXXXXXAAFFSSSKSSSIIIIIIIIINNNEEECFFFFFFFYNNNTTTTTTTTTTTTTTTPPPPPPPPPPPPRRBBBBBBRRRRRMMMMMMMRRRRR\nPQQQQQQQQQQGGGGGGGGKKKZZZZZMMMPPRDCCCCCCUUMMXXXXXXAAAASSKKSSSIIIIIIIIINNEEEECFFFFFFFYNNNNNTTTTTTTTTXTTTTTPPPPPPPPPGRBBBBBBBBRRRRMMMMMMMRRRRR\nQQQQQQQQQQQQQGGGGGGGKZZZZZZZMMMMDDDDDCDCDMMMMXXXRAAAAAKKKSSVVIIIIIIIIINEEEEEEFFFFFFFYSSSSBTTTTTTTTTXTTTPPPPPPPPPPPRRBBBBBBBBRRRMMMMMMMMMREER\nDQQQQQQQQQQQGGGGGGGGGGZZZZZZMMMMDDDDDDDDDDMMMXXXXAAAAIIIIIIIIIIIIIIIIIEEEEEEEFFFFFFFYSSSTTTTTTTTXXTXPPTPPPPPPPPPPPPPBBBBBBBBRRMMMMMMMMMMRMEE\nDQQQQQQQQQQGGGGGGGGGZZZZZZZZZMMMDDDDDDDDDDMMMMMXXAAAAIIIIIIIIIIIIIIIIIVVEEEEEFFFFFFFSSSSSTTTTTTTXXXXXPPPPPPPPPPPPPPPBBBBBBBBRRMMMMMMMMMMMMEE\nDDDQQQQQQQQGGGGGGGGGZZZZZZZZPUMMDDDDDDDDDDDDMMMMXMMAAIIIIIIIIIIIIIIIIIVVEEEEIFFFFFFFSSSSSSTTTTXXXXXXPPWPPPPPPPPPXPYUBBBBBBBBMMMMMMMMMMMMMMEE\nDDDQQQQQQGGGGGGGGGGGZZZZZZZPPUDDDDDDDDDDDDDDMMMMMMMAAIIIIIIIIIIIIIIIIIVVEEUESSSSSSSSSSSSSSTTKTXXXXXXXPWPPPPPPPPXXUUUUEEEEMMZMMMMMMMMMMMMEEEH\nDDDQQQQQQQGGGGGGGGGGGGGZZZZUUUDDDDDDDDDDDDDDMMMMMMAAAIIIIIIIIIIIIIIIIIVVUEUUUSSSSSSSSSSSSSXXXXXXXXXXXXXXXEEPPXXXXUUUUEMMEMMZMMMMMMMMMMMEEEEH\nDDDDCQCQQGGGGGGGGGGGLMZZZZZUUUUDUDDDDDDDDDDIIIIIIIIIAIIIIIIIIIIOVVVVVVVVUUUUUSSSSSSSSSSSSXXXXXXXXXXXXXLXEEEXXXXXXXUUMMMMMMMMMMMMMMMMMMMMEEHH\nDDDCCCCCCBBBGGGLGGMSMMZZZZZUUUUUUUDDDDDDDHHIIIIIIIIIAIIIIIIIIIIOOOVVVVVVUUUUUSSSSSSSSSSSSXXXXXXXXXXXXXLCEEXXXXXXXXUUUMMMMMMMMMMMUMMMMMMMHHHH\nCDDCCCCCCCBBGGGLGGMMMMMMMMUUUUUUWUUDDDDDDHHIIIIIIIIIAIIIIIIIIIIOOOVVVVVVVUUSSSSSSSSSSKKXXXXXXXXXXXXXXXCCCEEEXXXXXXXXUUMMMMMMMMUUUMMMMMMMHHHH\nCCCCCCCCCCCGGGOMMGMMMMMMYYYYYYWWWDDDDDDHHHHIIIIIIIIIIIIIIIIIIIIOOOOVVVVVVUNSSSSSSSSKKKKXXXXXXXXXXXXXXCCCXXXXXXXXXXXXXUMMMMMMUUUUUMMMMMMMHTHH\nCCCCCCCCCCCFGMMMMMMMMMMYYYYYYYYNWDDDDDDHHHHIIIIIIIIIIIIIIIIIIIIOOOOOVVQQNNNMMSSKKKKKKKKXXXXXXXXXXXXXXXSZZZXXXXXXXXXXXUUUMMMMUUUUUUUUMMMHHTTH\nCKKCCCCCCCCFFFMMMMMMMMMMYYYYYYYYWWDDDDDHHHHIIIIIIIIIIIIIILOOOOOOOOOOONNNNNNNNTSSKFKKKKXXXXGGGGXXXXXXXXSSZZXXXXXXXXXXUUUUUUUMUUUUUNUUQQMHLTTH\nKKKKCCCCCCKRRRRMMMMMMMMMMMYYYOYYYWWWWDHHHHHIIIIIIIIIIIIIILOOOOOOOOOOONNNNNNNNNNNNFKFFKKXXXGGGGXXXXXXXSSSSXXXXXXXXXUUUUUUUUUUUUUUUUUUUQMMLLTH\nKKKKKKKKKCKKRKKMMMMMMMMMMYYYYYYYYWWWWWHHHHHIIIIIIIIIIIIIILOOOOOOOOOOOYNNNNNNNNNNNFFFFFKKFXGGGGGGGXXXSSSSSXXXXXXXXXUUUUUUUUUUUUUUUUUUUULLLLHH\nKKKKKKKKKLLKKKKMMMMMMMMMMYYYYYYYYYYWWWWWHWHWWHHAAAAAAAAALOOOOOOOOOOVVNNNNNNNNNNNFFFFFFFFFFGGGGGGGXOXSSSSSSXXXXXXXUUUUUUUUUUUUUUUUUUUUULLLHHH\nKKKKKKKKLLLKKMMMMMMMMMMMYYYYYYYYYYWWWWWWWWHHWWAAAAAAAAOOOOOOOOOONNNVVVNNNNNNNNNNFFFFFFFFFFFGGGGGGXSSSSSSSSXXXXXXUUUUUUUUUUUUUUUUUUUUUULKLKKK\nKKKKKKKKKKLKKMMMMMMMMMMMYMMYYYYYYYYWWWWWWWWWWWAAAAAAAAOOOOOOOOOONNNNNNNNNNNNNNFFFFFFFFFFFFFGGGGGGSSSSSSSSSSXXXXXUUUUUUUUUUUUUUUUUUUUUUUKKKKK\nKKKKKKKKKKKKKMXXMMMMMMMMMMMMHHYYYWYYWWWWWWWWWWWAAAAAAAOOOOOOOOOOONNNNNNNNNNNNNFFFFFFFFHHHFGGGGGGSSSSSSSSSSSSXXXUUUUUUUUUUUUUUUUUUUUUUWUUKKKK\nKKKKKKKKKKKKKMXMMMMMMMMMMMMMMHYYYWWWWWWWWWWWWWAAAAAAAAAAOOOOOOOOOOONNNNANNNNNNFFFFFHHHHHHFGGGGGGSSSSSSSSSSSSXUUUUUUUUUUUUUUUUUUUUUUUUWWKKKKK"
                          
                          maskToChar  ""   = '-'
                          maskToChar (x:_) = x
                          
                          pointsToChar  ""   = '-'
                          pointsToChar (x:_) = x
                          
                          indexZOrder (PointsIndex _) (MaskIndex   _) = GT
                          indexZOrder (MaskIndex   _) (PointsIndex _) = LT
                          indexZOrder _ _ = EQ
                          
                          (height, world) = readAsciiWorld charMap inStr
                          asciiWorld' = setWidth 53 $ movePointsOfIndexBy "X" (1,1) world
                      in printAsciiWorld height bgChar maskToChar pointsToChar indexZOrder asciiWorld'

exampleOfMaskOperation3 = let bgChar = '.'
                          
                              charMap 'X' = Just (MaskIndex "X")
                              charMap 'Y' = Just (MaskIndex "Y")
                              charMap '.' = Nothing
                              charMap  _  = Just (MaskIndex "")
                              
                              inStr = "XYZ"
                              
                              maskToChar  ""   = '-'
                              maskToChar (x:_) = x
                              
                              pointsToChar  ""   = '-'
                              pointsToChar (x:_) = x
                              
                              indexZOrder (PointsIndex _) (MaskIndex   _) = LT
                              indexZOrder (MaskIndex   _) (PointsIndex _) = GT
                              indexZOrder _ _ = EQ
                              
                              (height, world) = readAsciiWorld charMap inStr :: (Int, AsciiWorld String String)
                          in (\(height,world) -> printAsciiWorld height bgChar maskToChar pointsToChar indexZOrder world) $ fmap (applyMask bitwiseXor " " "X" . moveMaskOfIndexBy " " (0,1) . copyMask "X" " ") $ (height, world)

exampleOfMaskOperation4 = let bgChar = '.'
                          
                              charMap 'X' = Just (MaskIndex "X")
                              charMap 'Y' = Just (MaskIndex "Y")
                              charMap '.' = Nothing
                              charMap  _  = Just (MaskIndex "")
                              
                              inStr = "XYZ"
                              
                              (height, world) = readAsciiWorld charMap inStr :: (Int, AsciiWorld String String)
                          in (\(height,world) -> print . popCount . fromJust . M.lookup "+" . asciiWorldMasks $ world) $ fmap (applyMask bitwiseXor "+" "X" . moveMaskOfIndexBy "+" (0,1) . copyMask "X" "+") $ (height, world)
